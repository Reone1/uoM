(window.webpackJsonp=window.webpackJsonp||[]).push([[69],{365:function(t,r,n){"use strict";n.r(r);var a=n(14),e=Object(a.a)({},(function(){var t=this,r=t._self._c;return r("ContentSlotsDistributor",{attrs:{"slot-key":t.$parent.slotKey}},[r("h1",{attrs:{id:"til-20210409"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#til-20210409"}},[t._v("#")]),t._v(" TIL-20210409")]),t._v(" "),r("h2",{attrs:{id:"today"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#today"}},[t._v("#")]),t._v(" Today")]),t._v(" "),r("ul",[r("li",[t._v("SQL 정규화")])]),t._v(" "),r("h2",{attrs:{id:"content"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#content"}},[t._v("#")]),t._v(" content")]),t._v(" "),r("h3",{attrs:{id:"정규화의-필요성"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#정규화의-필요성"}},[t._v("#")]),t._v(" 정규화의 필요성")]),t._v(" "),r("p",[t._v("관계형 데이터 베이스의 설계에서 "),r("strong",[t._v("중복을 최소화한 논리적 구조를 만드는 프로세스")]),t._v("를 정규화라 한다."),r("br"),t._v("\n이상있는 관계를 재구성하여 작고 잘 조직된 관계를 생성(논리적 구조를 형성)하는 것을 목표로 한다.")]),t._v(" "),r("p",[t._v("기본적으로 관계형데이터 베이스는 완전히 정규화 되게 디자인 되어야 한다. 그 뒤 일부가 성능상의 이유로 반정규화 될 수 있다.")]),t._v(" "),r("h3",{attrs:{id:"정규화의-방법-1nf-2nf-3nf-bcnf"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#정규화의-방법-1nf-2nf-3nf-bcnf"}},[t._v("#")]),t._v(" 정규화의 방법 1NF, 2NF, 3NF, BCNF")]),t._v(" "),r("ul",[r("li",[r("strong",[t._v("제 1 정규화 (1NF)")]),t._v("\n관계형 데이터베이스에서 각 컬럼(필드)는 하나의 값만 가져야 한다."),r("br"),t._v("\n만약 "),r("strong",[t._v("주문 리스트")]),t._v("라는 테이블이 있다면, 품목에는 여러가지가 있을 수 있다.")])]),t._v(" "),r("p",[t._v("이런 상화에서 품목을 하나씩 여러개의 행을 추가하여 테이블을 만드는 것을 "),r("strong",[t._v("제1 정규화")]),t._v("라고 한다.")]),t._v(" "),r("ul",[r("li",[r("strong",[t._v("제 2 정규화 (2NF)")]),t._v("\n2차 정규형은 테이블의 모든 컬럼이 완전 함수적 종석을 만족하는 것입니다."),r("br"),t._v("\n이게 무슨 말이냐면 기본키중에 특정 컬럼에만 "),r("strong",[t._v("종속된 컬럼(부분적 종속)이 없어야 한다")]),t._v("는 것입니다.")])]),t._v(" "),r("p",[t._v("변경되는 데이터에의해 반복적으로 나오는 데이터를 분리하는 것이 "),r("strong",[t._v("제 2 정규화")]),t._v("라 할 수 있다.")]),t._v(" "),r("ul",[r("li",[r("strong",[t._v("제 3 정규화")]),t._v("\n이행적 함수 종속이 되지 않도록 만드는 것이 "),r("strong",[t._v("제 3 정규화")]),t._v("이다.\n이행적 함수 종속이란 마치 삼단논법의 모양을 이루는 데이터를 말한다.\n"),r("code",[t._v("X -> Y AND Y -> Z => X -> Z")]),t._v("로 표현되게 되는 것이 이행적 함수 종속이 되는 것이다.")])]),t._v(" "),r("p",[t._v("하지만, 실제 데이터의 종속성이 "),r("code",[t._v("X -> Z")]),t._v("를 만족하지는 않기 때문에, "),r("code",[t._v("X -> Y")]),t._v("테이블과 "),r("code",[t._v("Y -> Z")]),t._v("테이블로 분리하면 된다.")]),t._v(" "),r("ul",[r("li",[r("strong",[t._v("BCNF(Boyce-Codd Normal Form)")]),t._v("\n지금까지 살펴본 세가지 릴레이션에서는 기본키가 될 수 있는 후보키가 하나 밖에 없었다.\n하지만 후보키를 여러개 가지고 있는 릴레이션에서는 제3정규형을 만족하더라도 이상현상이 생길 수 있다.\n이를 해결하기 위해 BCNF 정규화이다, 제3정규형보다 조금 더 엄격한 제약조건을 가지기 때문에 Strong 3NF 라고도 한다.\n"),r("a",{attrs:{href:"https://magok-leaders-coding.tistory.com/4",target:"_blank",rel:"noopener noreferrer"}},[t._v("참고자료"),r("OutboundLink")],1)])]),t._v(" "),r("h2",{attrs:{id:"referrence"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#referrence"}},[t._v("#")]),t._v(" Referrence")]),t._v(" "),r("ul",[r("li",[r("a",{attrs:{href:"https://3months.tistory.com/193",target:"_blank",rel:"noopener noreferrer"}},[t._v("데이터베이스 정규화 1NF, 2NF, 3NF, BCNF"),r("OutboundLink")],1)]),t._v(" "),r("li",[r("a",{attrs:{href:"https://datanetworkanalysis.github.io/2020/03/06/sql_normalization",target:"_blank",rel:"noopener noreferrer"}},[t._v("DNA sql nomalize"),r("OutboundLink")],1)]),t._v(" "),r("li",[r("a",{attrs:{href:"https://yaboong.github.io/database/2018/03/10/database-normalization-2",target:"_blank",rel:"noopener noreferrer"}},[r("OutboundLink")],1)])])])}),[],!1,null,null,null);r.default=e.exports}}]);