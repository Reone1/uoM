(window.webpackJsonp=window.webpackJsonp||[]).push([[75],{369:function(t,s,e){"use strict";e.r(s);var n=e(14),a=Object(n.a)({},(function(){var t=this,s=t._self._c;return s("ContentSlotsDistributor",{attrs:{"slot-key":t.$parent.slotKey}},[s("h1",{attrs:{id:"til-20210419"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#til-20210419"}},[t._v("#")]),t._v(" TIL-20210419")]),t._v(" "),s("h1",{attrs:{id:"today"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#today"}},[t._v("#")]),t._v(" Today")]),t._v(" "),s("ul",[s("li",[t._v("next와 typescript")])]),t._v(" "),s("h1",{attrs:{id:"content"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#content"}},[t._v("#")]),t._v(" content")]),t._v(" "),s("p",[t._v("정확히는 ts를 next에 적용하면서, mocha testing을 위한 환경 설정")]),t._v(" "),s("p",[t._v("ts compiling을 위한 tsconfig 파일이 있다.\nnext의 컴포넌트 등을 tsx, ts로 작성하면 어떻게 컴파일링 할지 결정하는 것이다.")]),t._v(" "),s("p",[t._v("ts를 통해서 es6, es5등의 코드로 변경하면, babel을 통해 순수 자바스크립트 코드로 다시 컴파일 한다.")]),t._v(" "),s("p",[t._v("tsconfig는 extends를 통해 상속 및 오버라이드가 가능하다.")]),t._v(" "),s("h2",{attrs:{id:"내가-겪은-문제"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#내가-겪은-문제"}},[t._v("#")]),t._v(" 내가 겪은 문제")]),t._v(" "),s("p",[t._v("nextjs에서 tsconfig는 jsx를 preserve속성으로 사용해야 매번 react module을 불러오지 않고도 component를 구성할 수 있다.\n하지만, mocha에서 component 테스트를 위해서는 react module을 불러와야 했고, react 모듈을 사용하여 jsx 문법을 사용하기 때문에, enzyme에서 '<' 토큰 에러가 발생했다.")]),t._v(" "),s("p",[t._v("토큰 에러의 발생으로 인해 tsconfig를 mocha test 환경에는 별도로 설정해야 했다.")]),t._v(" "),s("p",[t._v("ts-node를 통해 가상 메모리 환경을 만들어 mocha test를 진행하고 있어서\nts-node에 다른 tsconfig를 할당하여 해결하기로 했다.")]),t._v(" "),s("p",[t._v("ts-node에 다른 config를 설정하기 위해 "),s("code",[t._v("TS_NODE_PROJECT")]),t._v("를 통해 config 파일을 전달해 주었다.")])])}),[],!1,null,null,null);s.default=a.exports}}]);