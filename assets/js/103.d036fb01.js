(window.webpackJsonp=window.webpackJsonp||[]).push([[103],{399:function(t,e,n){"use strict";n.r(e);var a=n(14),r=Object(a.a)({},(function(){var t=this,e=t._self._c;return e("ContentSlotsDistributor",{attrs:{"slot-key":t.$parent.slotKey}},[e("h1",{attrs:{id:"til-20211123"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#til-20211123"}},[t._v("#")]),t._v(" TIL-20211123")]),t._v(" "),e("h2",{attrs:{id:"today"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#today"}},[t._v("#")]),t._v(" Today")]),t._v(" "),e("ul",[e("li",[t._v("nextjs middleware")])]),t._v(" "),e("h2",{attrs:{id:"contents"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#contents"}},[t._v("#")]),t._v(" Contents")]),t._v(" "),e("ul",[e("li",[e("p",[e("code",[t._v("nextJs")]),t._v(" middleware\nnextjs에서 미들웨어를 설정해 사용자 정보를 cookie에 저장하고 해당 cookie정보를 통해 인증 로직을 구현하는 방식을 적용해 보았습니다.\nfront에서 간편한 인증 서버를 구현하는게 가능했고, jwt token 이외에도 page, rendering관련 authentication을 관리할 수 있어서 편리한 느낌이 있었습니다.")]),t._v(" "),e("p",[t._v("실제 인증관련 정보 (database)는 backend를 통해서 (nest) 구현 한 상태에서, front routing 단계의 세팅을 적용하기 위해 middleware는 편리한 기능으로 생각 됩니다.")]),t._v(" "),e("p",[t._v("next에서의 server기능을 사용해서 client request를 기반으로 작동하며, cookie, page parameter등 client request의 대부분의 기능을 가지고 요청을 처리할 수 있습니다.\npage에 따른 condition 관리 전략을 정할 수 있다면, utility를 구성하여 선택적인 middleware를 구동하는게 편리해 보입니다.")])])]),t._v(" "),e("h2",{attrs:{id:"conclusion"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#conclusion"}},[t._v("#")]),t._v(" Conclusion")]),t._v(" "),e("p",[t._v("NextJs를 최대한 활용하기 위해 프론트 서버의 기능을 많이 사용할 계획입니다. 하지만, rendering관련 기능 이외의 기능을 추가하는 것은 진행하지 않도록하여 monolithic한 구조의 front를 구성하는 것은 피할 계획입니다.")])])}),[],!1,null,null,null);e.default=r.exports}}]);