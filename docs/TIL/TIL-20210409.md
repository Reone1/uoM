# TIL-20210409

## Today

- SQL 정규화

## content

### 정규화의 필요성

관계형 데이터 베이스의 설계에서 **중복을 최소화한 논리적 구조를 만드는 프로세스**를 정규화라 한다.  
이상있는 관계를 재구성하여 작고 잘 조직된 관계를 생성(논리적 구조를 형성)하는 것을 목표로 한다.

기본적으로 관계형데이터 베이스는 완전히 정규화 되게 디자인 되어야 한다. 그 뒤 일부가 성능상의 이유로 반정규화 될 수 있다.

### 정규화의 방법 1NF, 2NF, 3NF, BCNF

- **제 1 정규화 (1NF)**
관계형 데이터베이스에서 각 컬럼(필드)는 하나의 값만 가져야 한다.  
만약 **주문 리스트**라는 테이블이 있다면, 품목에는 여러가지가 있을 수 있다.  

이런 상화에서 품목을 하나씩 여러개의 행을 추가하여 테이블을 만드는 것을 **제1 정규화**라고 한다.  

- **제 2 정규화 (2NF)**
2차 정규형은 테이블의 모든 컬럼이 완전 함수적 종석을 만족하는 것입니다.  
이게 무슨 말이냐면 기본키중에 특정 컬럼에만 **종속된 컬럼(부분적 종속)이 없어야 한다**는 것입니다.  

변경되는 데이터에의해 반복적으로 나오는 데이터를 분리하는 것이 **제 2 정규화**라 할 수 있다.

- **제 3 정규화**
이행적 함수 종속이 되지 않도록 만드는 것이 **제 3 정규화**이다.
이행적 함수 종속이란 마치 삼단논법의 모양을 이루는 데이터를 말한다.
`X -> Y AND Y -> Z  => X -> Z`로 표현되게 되는 것이 이행적 함수 종속이 되는 것이다.

하지만, 실제 데이터의 종속성이 `X -> Z`를 만족하지는 않기 때문에, `X -> Y`테이블과 `Y -> Z`테이블로 분리하면 된다.

- **BCNF(Boyce-Codd Normal Form)**
지금까지 살펴본 세가지 릴레이션에서는 기본키가 될 수 있는 후보키가 하나 밖에 없었다.
하지만 후보키를 여러개 가지고 있는 릴레이션에서는 제3정규형을 만족하더라도 이상현상이 생길 수 있다.
이를 해결하기 위해 BCNF 정규화이다, 제3정규형보다 조금 더 엄격한 제약조건을 가지기 때문에 Strong 3NF 라고도 한다.
[참고자료](https://magok-leaders-coding.tistory.com/4)

## Referrence

- [데이터베이스 정규화 1NF, 2NF, 3NF, BCNF](https://3months.tistory.com/193)  
- [DNA sql nomalize](https://datanetworkanalysis.github.io/2020/03/06/sql_normalization)
- [](https://yaboong.github.io/database/2018/03/10/database-normalization-2)